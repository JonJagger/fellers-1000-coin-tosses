<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Feller's coin tosses</title>    
    <script src="jquery-1.8.3.js"           type="text/javascript"></script>
    <script src="jquery.flot.js"            type="text/javascript" ></script>
    <script src="jquery.flot.axislabels.js" type="text/javascript" ></script>
    <script src="jquery-ui.js"              type="text/javascript" ></script>
    <script src="jstat-core.js"             type="text/javascript" ></script>
    <script src="jstat-vector.js"           type="text/javascript" ></script>
    <link   href="jquery-ui.css"            type="text/css" rel="stylesheet">

    <script type="text/javascript">

        // Code to investigate Feller's walk
        //
        // Image you have a fair coin, and you flip it 1000 times.
        // These 1000 coin flips comprise one walk.
        // Each time you flip a head you add 1 to your total.
        // Each time you flip a tail you subtract 1 from your total.
        //
        // What will the cumulative total look like as the number of coin
        // flips progresses from 1 to 1000?
        //
        // http://jonjagger.blogspot.co.uk/2013/01/fellers-walk.html        
        //
        // It is important to understand that...
        // *** if the number of steps is even
        //     the total is always even.
        // *** if the number of steps is odd
        //     the total is always odd.
        //
        // Suppose the number of steps in a walk == 4.
        // Possibilities are:
        //     0H 4T == 0-4 == -4
        //     1H 3T == 1-3 == -2
        //     2H 2T == 2-2 ==  0
        //     3H 1T == 3-1 == +2
        //     4H 0T == 4-0 == +4
        //
        // Suppose the number of steps in a walk == 5.
        // Possibilities are:
        //     0H 5T == 0-5 == -5
        //     1H 4T == 1-4 == -3
        //     2H 3T == 2-3 == -1
        //     3H 2T == 3-2 == +1
        //     4H 1T == 4-1 == +3
        //     5H 0T == 5-0 == +5
        
        var NUMBER_OF_WALKS = 5000;
        var FLIPS_PER_WALK = 1000;
        var WALKS_PER_PLOT = 100;
        
        function doOneWalk() {            
            var HEAD = +1;
            var TAIL = -1;
            var walk = [ [0,0] ];
            var total = 0;
                        
            for (var flip = 1; flip !== FLIPS_PER_WALK+1; flip++) {
                if (feedback.nudge()) {
                    // I must _not_ tweak the feedback like this:
                    //    if (total < 0)
                    //      total += 1;
                    //    if (total > 0)
                    //      total -= 1;
                    // If I do this, then for the case when total === 0
                    // I will _not_ do a head(+1) or a tail(-1) at all.
                    // This will alter the final total to be odd when
                    // its normally even (or vice versa). See ***
                    // Thus I will get an outlier in the plot data set.
                    //
                    // Consider what happens to the total when a feedback
                    // nudge happens...
                    //   50% of the time it would have gone towards zero
                    //     in this case the nudge has no effect
                    //   50% of the time it would have gone away from zero
                    //     in this case the nudge has a net effect of +-2
                    // so
                    //   the net effect is +-1 (towards zero) per nudge
                    //   thus the odd/even-ness is preserved.
                    //
                    // Consider also, if the code did this...
                    //   var toss = (total < 0) ? HEAD : TAIL;
                    //   total += toss;
                    //   if (feedback()) {
                    //     total -= toss; 
                    //   }
                    // In this case a nudge would have no net effect on the
                    // total and the odd/even-ness would not be preserved.                    
                    total += (total < 0) ? HEAD : TAIL;
                } else {
                    total += (Math.random() < 0.5) ? HEAD : TAIL;
                }
                
                if (flip % 5 === 0) {
                    walk.push([flip,total]);
                }
                
                $.each(counts.points, function(_,point) {
                    if (flip === point) {
                        counts[point].record(total);    
                    }
                });
            }
            return walk;
        }       
                
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // What are the effects of adding feedback, of nudging
        // the total back towards zero every so often...?
        // To get a feedback nudge every Nth throw (on average)
        // call feedback.reset(N). To get no feedback use N == zero.
        
        var feedback = {
            expectedCount: undefined,
            actualCount: 0,
            ordinals: undefined,
        };
                
        feedback.nudge = function() {
            // Deliberately independent of the walk number
            var my = feedback;
            my.ordinals.shuffle();
            if (my.ordinals[0] === 0) {
                my.actualCount += 1;
                return true;
            } else {
                return false;                
            }
        }        
        
        feedback.expected = function() {
            var my = feedback;
            return (my.expectedCount === 0)
                ? 'never'
                : my.expectedCount;            
        }
        
        feedback.actual = function(n) {
            var my = feedback;
            return (my.actualCount === 0)
                ? 'never'
                : (1 / (my.actualCount / (FLIPS_PER_WALK * n))).toFixed(2);                
        }
        
        feedback.reset = function(n) {
            var my = feedback;
            my.actualCount = 0;
            my.expectedCount = n;
            my.ordinals = my.makeOrdinals(n);
        }
        
        feedback.makeOrdinals = function(n) {
            var array = [ ];
            for (var at = 0; at !== n; at++) {
                array.push(at);
            }
            array.shuffle = function() {
                // Fischer-Yates shuffle (after Ronald Fisher)
                // http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
                var i = this.length, j, temp;
                if (i === 0) {
                    return;
                }
                while (--i) {
                   j = Math.floor(Math.random() * (i + 1));
                   temp = this[i];
                   this[i] = this[j];
                   this[j] = temp;
                }
            }
            return array;            
        }
                        
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // Counts of cumulative total after N coin flips where N=50,100,1000
        
        var counts = [ ];
        
        counts.points = [ 50,100,FLIPS_PER_WALK ];
        
        counts.getPoint = function(n) {
            return counts.points[n];
        }
        
        counts.getPlot = function(n) {
            return counts[counts.points[n]].getPlot();    
        }
        
        counts.reset = function() {
            var NEG = 0;
            var POS = 1;
            var TOTAL = 0;
            var COUNT = 1;
            counts.flotData = function() {
                // flot.js requires an array of data-points.
                // My bottom graph is centered on x==zero, so half
                // of the x values will be negative.
                // But javascript cannot use negative array indexes.
                // So I use one array for -ve x-values and
                // one array for +ve x-values.
                //   eg flot[NEG][35] => [-35,455] 
                //   eg flot[POS][12] => [12,623]
                // I reverse this in flot.makePlot() 
                
                var flot = [ [/*NEG*/], [/*POS*/] ];
                                
                flot.record = function(total) {
                    var np = (total < 0) ? NEG : POS;
                    var absTotal = Math.abs(total);
                    var element = this[np][absTotal];
                    if (element === undefined) {
                        element = this[np][absTotal] = [ ];
                        element[TOTAL] = total;
                        element[COUNT] = 0;
                    }
                    element[COUNT] += 1;            
                }
                                
                flot.makePlot = function() {
                    var element;
                    var plot = [ ];
                    var neg = this[NEG];
                    for (var at = neg.length - 1; at >= 0; at--) {
                        element = neg[at];
                        if (element !== undefined) {
                            plot.push(element);
                        }
                    }
                    var pos = this[POS];
                    for (var at = 0; at < pos.length; at++) {
                        element = pos[at];
                        if (element !== undefined) {
                            plot.push(element);
                        }
                    }
                    return plot;
                }
                
                flot.getPlot = function() {
                    var plot = this.makePlot();
                    
                    plot.rangeOfTotals = function() {
                        var min = this[0][TOTAL];
                        var max = this[this.length - 1][TOTAL];
                        return min + ',' + max;
                    }
                    
                    plot.countAtTotalZero = function() {
                        var element;
                        for (var at = 0; at !== this.length; at++) {
                            element = this[at];
                            if (element[TOTAL] === 0) {
                                return element[COUNT];
                            }
                        }
                        return '?';
                    }
                    
                    plot.stdDev = function() {
                        var element, total, count;
                        var raw = [ ];
                        // Eg [...[45,3]...] ==> [...[45] [45] [45]...]
                        // There's probably a faster way of calculating
                        // std.dev with data in this format but this
                        // brute force approach is good enough.
                        for (var at = 0; at !== this.length; at++) {
                            element = this[at];
                            if (element !== undefined) {
                                total = element[TOTAL];
                                count = element[COUNT];
                                for (var i = 0; i !== count; i++) {
                                    raw.push(total);
                                }
                            }
                        }
                        return jStat.stdev(raw).toFixed(2);
                    }                    
                    return plot;
                }                            
                return flot;
            }
            counts.length = 0;
            $.each(counts.points, function(_,point) {
                counts[point] = counts.flotData();
            });
        }
                
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        // UI code from here
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        
        function display(n,walk) {
            function labeledCountPlot(n) {
                return {
                    label: "after " + counts.getPoint(n) + " flips",
                    data: counts.getPlot(n)
                }
            }
            function walkLabel() {
                var percentDone = (n / NUMBER_OF_WALKS * 100).toFixed(0);
                return n + "th Walk (" + percentDone + "%)";
            }
            function stat(kind,n) {
                return $('.stats #flips_' + n + ' #' + kind);    
            }
            
            var countPlots =
                [ 
                    labeledCountPlot(0),
                    labeledCountPlot(1),
                    labeledCountPlot(2),
                ];
                        
            $.plot($("#fellers-walk"),
                   [ { label: walkLabel(), data: walk } ],
                   plotOptions.forWalk(walk));
            
            $.plot($("#fellers-counts"),
                   countPlots,
                   plotOptions.forCounts());
            
            for (var at = 0; at !== countPlots.length; at++) {
                $('.stats #flips_'+at+' th').html(counts.getPoint(at));
                stat('total',  at).html(countPlots[at].data.countAtTotalZero());
                stat('range',  at).html(countPlots[at].data.rangeOfTotals());
                stat('std_dev',at).html(countPlots[at].data.stdDev());                            
            }
            
            $('.feedback #expected').html(feedback.expected());
            $('.feedback #actual').html(feedback.actual(n));
        }
        
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - -
                
        var plotOptions = {
            forCounts: function() {                            
                return {
                    legend: { position: "nw" },                                
                    xaxis: {
                        axisLabel: "count&uarr; &larr;total&rarr;",
                        position: "bottom",
                    },
                    series: {
                        lines: { show: true },
                        points: { show: false }
                    }
                };                        
            },
            forWalk: function(walk) {
                return {
                    legend: { position: "nw" },                                
                    xaxis: {
                        axisLabel: "total&uarr; flip&rarr;", 
                        position: "bottom",
                        min: 0,
                        max: FLIPS_PER_WALK
                    },
                    yaxis: {
                        tickDecimals: 0,
                        min: -50,
                        max: 50                    
                    },
                    series: {
                        color: "green",
                        lines: { show: true },
                        points: { show: false }
                    }
                };            
            }            
        };
                          
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                
        function makeReRunDialogHtml() {
            return '' +
                '<table>' +
                  '<tr>' +
                    '<td>' +
                      '<label>nudge towards zero every</label>' +
                    '</td>' +
                    '<td>' +  
                      '<input type="text"' +
                             'style="width:3em;"' +
                             'value="' + feedback.expectedCount + '"' +
                             'id="feedback">' +
                       '&nbsp;th flip (0 for never)' +
                    '</td>' +
                  '</tr>' +
                  '<tr>' +
                    '<td>' +
                      '<label>number of walks&nbsp;</label>' +
                    '</td>' +
                    '<td>' +
                      '<input type="text"' +
                             'style="width:5em;"' +
                             'value="' + NUMBER_OF_WALKS + '"' +
                             'id="no_of_walks">' +
                    '</td>' +
                  '</tr>' +                      
                  '<tr>' +
                    '<td>' +
                      '<label>flips per walk&nbsp;</label>' +
                    '</td>' +
                    '<td>' +
                      '<input type="text"' +
                             'style="width:5em;"' +
                             'value="' + FLIPS_PER_WALK + '"' +
                             'id="flips_per_walk">' +
                    '</td>' +
                  '</tr>' +                      
                '</table>';            
        }
                
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                
        function makeHelpHtml() {            
            return '' +
                '<div>' +
                  'Image you have a fair coin, and you flip it 1000 times, ' +
                  'adding one or subtracting one each time you flip either ' +
                  'a head or a tail respectively. ' +
                  '<br><br>' +
                  'How will the cumulative total behave as ' +
                  'the number of coin flips progresses from 1 to 1000 ?' +
                  '<br><br>' +
                  'Suppose you occasionally nudge the total back towards zero. ' +
                  'How effective are these nudges? ' +
                  '<br><br>' +
                  'The top graph shows individual walks, in green, rising as ' +
                  'the total increases, dropping as the total decreases.' +
                  '<br><br>' +
                  'The bottom graph shows how often each total has occurred. ' +
                  'For example, the blue line plots the total after 100 coin ' +
                  'flips into each walk. A point (6,300) on the blue line means ' +
                  '300 walks had a total of 6 after 100 coin flips. ' +
                '</div>';
        }
        
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        
        function showHelp() {
            var html = $(makeHelpHtml());
            var help = html.dialog({	  
                title: "help",
                autoOpen: false,
                width: 700,
                modal: true,
                buttons: {
                  ok: function() {
                    $(this).dialog('close');
                  }
                }
              });
            help.dialog('open');            
        }
        
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

        function reRunSimulation() {
            var html = $(makeReRunDialogHtml());
            //TODO: hit enter on feedback input to ok the dialog
            var setup = html.dialog({	  
                title: "Feller's walk",
                autoOpen: false,
                width: 550,
                modal: true,
                buttons: {
                  ok: function() {
                    //TODO: check input
                    feedback.reset(parseInt($('#feedback',html).val()));
                    NUMBER_OF_WALKS = parseInt($('#no_of_walks',html).val());
                    FLIPS_PER_WALK = parseInt($('#flips_per_walk',html).val());
                    counts.points.pop();
                    counts.points.push(FLIPS_PER_WALK);
                    runSimulation();
                    $(this).dialog('close');
                  },
                  cancel: function() {
                    $(this).dialog('close');
                  }
                }
              });
            setup.dialog('open');
        }
        
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        
        var fid = undefined;
        
        function runSimulation() {
            var n = 0;
            clearInterval(fid);            
            counts.reset();
            // Can't use for-loop (the plots don't appear?!)            
            fid = setInterval(
                function() {
                    if (n++ === NUMBER_OF_WALKS) {
                        clearInterval(fid);
                    } else {
                        var walk = doOneWalk();
                        if (n % WALKS_PER_PLOT === 0) {
                            display(n, walk);
                        }                                    
                    }                   
                },
                0);            
        }
                     
        //- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                           
        $(document).ready(function() {
            $('#run_again').click(function() {
                reRunSimulation();
            });
            $('#help').click(function() {
                showHelp();
            });
            feedback.reset(0);
            runSimulation();
            showHelp();
        });
        
    </script>
    
    <style type="text/css">
        #fellers-walk, #fellers-counts {
            width: 1100px;
            height: 290px;
        }
        .stats, .feedback {
            font-size: 0.8em;
        }
        table {
            display: inline-block;
            border-collapse: collapse;
            border-spacing: 0;
        }
        .stats td, .stats th, .feedback td {
            border: solid 1px gray;
            padding: 0.25em;
        }
        .feedback caption {
            font-weight: bold;
        }
        .ui-dialog {
              opacity: 0.75;
        }    
    </style>      
</head>
<body>
    
<table>
    <tr>
        <td><div id="fellers-walk"></div></td>
    </tr>
    <tr>
        <td><div id="fellers-counts"></div></td>
    </tr>
</table>
    
<table>
    <tr>
        <td>
            <table>
                <tr>
                    <td>
                        <input type="button" id="run_again" value="run again">
                    </td>
                </tr>
                <tr>
                    <td>
                        <input type="button" id="help" value="help">
                    </td>
                </tr>
            </table>
        </td>
        <td>    
            <table class="stats">
                <tr>
                    <th>flips</th>
                    <th>count[0]</th>
                    <th>range</th>
                    <th>std.dev</th>
                </tr>
                <tr id="flips_0">
                    <th></th>
                    <td id="total"></td>
                    <td id="range"></td>
                    <td id="std_dev"></td>
                </tr>
                <tr id="flips_1">
                    <th></th>
                    <td id="total"></td>
                    <td id="range"></td>
                    <td id="std_dev"></td>
                </tr>
                <tr id="flips_2">
                    <th></th>
                    <td id="total"></td>
                    <td id="range"></td>
                    <td id="std_dev"></td>            
                </tr>
            </table>
        </td>
        <td>
            <table class="feedback">
                <caption>flips / nudge</caption>
                <tr>
                    <td>expected</td>
                    <td id="expected"></td>
                </tr>
                <tr>
                    <td>actual</td>
                    <td id="actual"></td>
                </tr>
            </table>
        </td>
    </tr>
</table>
    
</body>
</html>
